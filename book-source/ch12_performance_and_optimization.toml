[chapter]
number = 12
title = "Performance and Optimization"
description = "Master performance optimization techniques for production-grade Computo and Permuto transformations"

[chapter.learning_objectives]
primary = "Write high-performance transformations that scale efficiently with large datasets"
secondary = [
    "Master the use of 'let' for eliminating redundant computations",
    "Understand lazy evaluation and computational deferral strategies", 
    "Apply pipeline ordering techniques for optimal performance",
    "Leverage tail call optimization for complex nested logic",
    "Implement memory-efficient patterns for large-scale data processing"
]

[chapter.prerequisites]
knowledge = ["Advanced array operations", "Complex nested transformations", "Template-driven patterns"]
tools = ["Computo CLI", "Performance monitoring tools"]

[[sections]]
title = "The Golden Rule: Strategic Use of let"
content = """
The single most important optimization technique in Computo is the strategic use of the `let` operator. Every time you write an expression that might be used more than once, consider binding it to a variable.

## The Performance Impact

Consider this common anti-pattern where the same expensive operation is repeated:

```json
["obj",
  ["user_name", ["get", ["get", ["$input"], "/users"], "/current_user"], "/name"]],
  ["user_email", ["get", ["get", ["$input"], "/users"], "/current_user"], "/email"]],
  ["user_role", ["get", ["get", ["$input"], "/users"], "/current_user"], "/role"]],
  ["user_department", ["get", ["get", ["$input"], "/users"], "/current_user"], "/department"]]
]
```

Here, `["get", ["$input"], "/users"]` is evaluated **four times**, and the user lookup is repeated **four times**. This redundancy compounds exponentially with data size.

## The Optimized Approach

Using `let` strategically eliminates all redundant computations:

```json
["let", [
    ["users", ["get", ["$input"], "/users"]],
    ["current_user", ["get", ["$", "/users"], "/current_user"]]
  ],
  ["obj",
    ["user_name", ["get", ["$", "/current_user"], "/name"]],
    ["user_email", ["get", ["$", "/current_user"], "/email"]],
    ["user_role", ["get", ["$", "/current_user"], "/role"]],
    ["user_department", ["get", ["$", "/current_user"], "/department"]]
  ]
]
```

**Performance Benefits:**
- Expensive operations executed once instead of multiple times
- Intermediate results stored once rather than recomputed
- Variable names make the script self-documenting
- Changes to complex expressions need only be made in one place

## When to Use let

Use `let` when you have:
- Complex `get` expressions used multiple times
- Expensive calculations (arithmetic, array operations)
- Template applications that might be reused
- Any expression that takes non-trivial time to compute

**Rule of thumb**: If you copy-paste an expression, use `let` instead.
"""

[[sections]]
title = "Mastering Lazy Evaluation"
content = """
Computo's `if` operator implements lazy evaluation, meaning it only executes the branch that is actually taken. This has profound performance implications for conditional logic.

## The Anti-Pattern: Pre-Computing Everything

```json
["let", [
    ["expensive_report", ["reduce",
      ["map", ["get", ["$input"], "/data"], 
        ["lambda", ["item"], ["complex_calculation", ["$", "/item"]]]
      ],
      ["lambda", ["acc", "val"], ["merge", ["$", "/acc"], ["$", "/val"]]],
      {}
    ]],
    ["simple_summary", ["obj", 
      ["count", ["count", ["get", ["$input"], "/data"]]],
      ["status", "basic"]
    ]]
  ],
  ["if", ["get", ["$input"], "/user/wants_detailed_report"],
    ["$", "/expensive_report"],
    ["$", "/simple_summary"]
  ]
]
```

**Problem**: Both the expensive report AND the simple summary are computed every time, even though only one will be used.

## The Optimized Pattern: Lazy Computation

```json
["if", ["get", ["$input"], "/user/wants_detailed_report"],
  ["reduce",
    ["map", ["get", ["$input"], "/data"], 
      ["lambda", ["item"], ["complex_calculation", ["$", "/item"]]]
    ],
    ["lambda", ["acc", "val"], ["merge", ["$", "/acc"], ["$", "/val"]]],
    {}
  ],
  ["obj", 
    ["count", ["count", ["get", ["$input"], "/data"]]],
    ["status", "basic"]
  ]
]
```

**Benefit**: Only the needed computation is performed, potentially saving orders of magnitude in processing time.

## Advanced Lazy Patterns

### Multi-Level Conditional Deferral
```json
["if", ["get", ["$input"], "/user/role"],
  ["if", ["==", ["get", ["$input"], "/user/role"], "admin"],
    ["obj", ["dashboard", "admin"], ["features", "all"]],
    ["if", ["==", ["get", ["$input"], "/user/role"], "manager"],
      ["obj", ["dashboard", "manager"], ["features", "limited"]],
      ["obj", ["dashboard", "user"], ["features", "basic"]]
    ]
  ],
  ["obj", ["dashboard", "guest"], ["features", "minimal"]]
]
```

### Conditional Template Application
```json
["if", ["get", ["$input"], "/enable_templating"],
  ["permuto.apply",
    ["get", ["$input"], "/complex_template"],
    ["$input"]
  ],
  ["$input"]
]
```

**Key principle**: Move expensive computations inside the `if` branches that actually need them.
"""

[[sections]]
title = "Pipeline Ordering for Maximum Efficiency"
content = """
The order of operations in data processing pipelines can dramatically impact performance. The fundamental principle is: **reduce data volume as early as possible**.

## The Classic Anti-Pattern

Consider extracting names of active users from a large dataset:

```json
["map",
  ["filter",
    ["map", ["get", ["$input"], "/users"],
      ["lambda", ["u"], 
        ["obj",
          ["name", ["get", ["$", "/u"], "/profile/name"]],
          ["email", ["get", ["$", "/u"], "/contact/email"]],
          ["active", ["get", ["$", "/u"], "/status/active"]],
          ["department", ["get", ["$", "/u"], "/org/department"]]
        ]
      ]
    ],
    ["lambda", ["u"], ["get", ["$", "/u"], "/active"]]
  ],
  ["lambda", ["u"], ["get", ["$", "/u"], "/name"]]
]
```

**Problems:**
- Creates complex objects for ALL users first
- Then filters out most of them
- Wastes memory and CPU on discarded objects

## The Optimized Pipeline

```json
["map",
  ["filter", ["get", ["$input"], "/users"],
    ["lambda", ["u"], ["get", ["$", "/u"], "/status/active"]]
  ],
  ["lambda", ["u"], ["get", ["$", "/u"], "/profile/name"]]
]
```

**Performance improvements:**
- With 10,000 users, 100 active: Original processes 10,000 â†’ 100. Optimized processes 100.
- Memory usage reduced by ~90%
- CPU usage proportionally reduced

## The Universal Rule

**Always filter as early as you can to reduce the amount of data that later stages need to process.**

### Multi-Stage Filtering
```json
["let", [
    ["users", ["get", ["$input"], "/users"]],
    ["active_users", ["filter", ["$", "/users"],
      ["lambda", ["u"], ["get", ["$", "/u"], "/status/active"]]
    ]],
    ["recent_users", ["filter", ["$", "/active_users"],
      ["lambda", ["u"], [">", ["get", ["$", "/u"], "/last_login"], 
        ["get", ["$input"], "/cutoff_date"]]]
    ]]
  ],
  ["map", ["$", "/recent_users"],
    ["lambda", ["u"], 
      ["obj",
        ["name", ["get", ["$", "/u"], "/name"]],
        ["department", ["get", ["$", "/u"], "/department"]]
      ]
    ]
  ]
]
```

This pattern progressively narrows the dataset before doing expensive transformations.
"""

[[sections]]
title = "Tail Call Optimization and Deep Nesting"
content = """
Computo implements automatic tail call optimization (TCO), eliminating stack overflow concerns and enabling arbitrarily deep nesting patterns for complex business logic.

## What This Means for You

Traditional recursive or deeply nested programs can exhaust the call stack. Computo's TCO provides:

- **No stack limits**: Nest conditionals and operations as deeply as needed
- **Consistent performance**: Deep nesting doesn't degrade performance  
- **Memory efficiency**: No stack frame accumulation
- **Production reliability**: No unexpected stack overflow errors

## Deep Conditional Trees

```json
["let", [
    ["user", ["get", ["$input"], "/user"]],
    ["account", ["get", ["$input"], "/account"]],
    ["transaction", ["get", ["$input"], "/transaction"]]
  ],
  ["if", ["get", ["$", "/user"], "/active"],
    ["if", ["get", ["$", "/account"], "/verified"],
      ["if", [">", ["get", ["$", "/account"], "/balance"], 
             ["get", ["$", "/transaction"], "/amount"]],
        ["if", ["==", ["get", ["$", "/transaction"], "/type"], "withdrawal"],
          ["if", ["<=", ["get", ["$", "/transaction"], "/amount"], 
                 ["get", ["$", "/account"], "/daily_limit"]],
            ["if", ["get", ["$", "/user"], "/two_factor_enabled"],
              ["obj", ["status", "approved"], ["action", "withdrawal_processed"]],
              ["obj", ["status", "requires_2fa"], ["action", "request_verification"]]
            ],
            ["obj", ["status", "rejected"], ["reason", "over_daily_limit"]]
          ],
          ["obj", ["status", "processed"], ["type", "other_transaction"]]
        ],
        ["obj", ["status", "rejected"], ["reason", "insufficient_funds"]]
      ],
      ["obj", ["status", "rejected"], ["reason", "account_not_verified"]]
    ],
    ["obj", ["status", "rejected"], ["reason", "user_inactive"]]
  ]
]
```

This nested structure (6 levels deep) would cause stack overflow in many systems, but runs efficiently in Computo.

## Practical Benefits

1. **Complex conditional trees**: Nest `if` statements arbitrarily deep without performance degradation
2. **Deep `let` scoping**: Nested variable scopes don't consume stack space
3. **Programmatic generation**: Generated scripts with deep nesting work reliably
4. **No configuration needed**: TCO is automatic and always enabled

This optimization makes Computo robust for complex business logic and machine-generated transformations where nesting depth might be unpredictable.
"""

[chapter.summary]
content = """
You've mastered the essential performance optimization techniques for production-grade Computo transformations:

**Key Optimization Strategies:**
- **Strategic `let` usage**: Eliminate redundant computations by binding expensive operations to variables
- **Lazy evaluation mastery**: Leverage `if` operator lazy evaluation to defer expensive computations until needed  
- **Pipeline optimization**: Structure data processing to filter early and minimize intermediate data volume
- **TCO advantages**: Write deeply nested logic without stack overflow concerns

**Performance Rules of Thumb:**
1. Use `let` for any expression used more than once
2. Move expensive computations inside `if` branches when possible
3. Filter data as early as possible in processing pipelines
4. Don't worry about nesting depth - TCO handles it efficiently

These optimization patterns enable your transformations to scale from small scripts to enterprise-grade data processing pipelines handling millions of records efficiently.

**Next**: Chapter 13 covers error handling and debugging techniques to make your optimized transformations robust and maintainable.
"""

[[examples]]
name = "let_optimization_comparison"
description = "Compare performance impact of redundant vs optimized expressions"
section = "general"
tutorial_text = "This example demonstrates the performance difference between scripts with redundant expressions and those optimized with let bindings."

script = ["obj",
  ["inefficient_total", ["+",
    ["*", ["get", ["$input"], "/price"], ["get", ["$input"], "/quantity"]],
    ["*", ["*", ["get", ["$input"], "/price"], ["get", ["$input"], "/quantity"]], 0.08]
  ]],
  ["optimized_total", ["let", [
      ["price", ["get", ["$input"], "/price"]],
      ["quantity", ["get", ["$input"], "/quantity"]],
      ["subtotal", ["*", ["$", "/price"], ["$", "/quantity"]]],
      ["tax", ["*", ["$", "/subtotal"], 0.08]]
    ],
    ["+", ["$", "/subtotal"], ["$", "/tax"]]
  ]]
]

input = { price = 29.99, quantity = 3 }

expected = { inefficient_total = 97.1676, optimized_total = 97.1676 }

notes = "Both approaches produce the same result, but the optimized version avoids redundant calculations and improves readability."
cli_flags = ["--pretty=2"]

[[examples]]
name = "pipeline_ordering_optimization"
description = "Compare inefficient vs optimized pipeline ordering for array operations"
section = "general"
tutorial_text = "This example demonstrates the performance impact of proper pipeline ordering by filtering before mapping."

script = ["let", [
    ["users", ["get", ["$input"], "/users"]],
    ["active_threshold", ["get", ["$input"], "/active_days_threshold"]]
  ],
  ["obj",
    ["optimized_pipeline", ["map",
      ["filter", ["$", "/users"],
        ["lambda", ["user"], [">", ["get", ["$", "/user"], "/last_active_days"], ["$", "/active_threshold"]]]
      ],
      ["lambda", ["user"], 
        ["obj",
          ["name", ["get", ["$", "/user"], "/name"]],
          ["department", ["get", ["$", "/user"], "/department"]],
          ["activity_score", ["*", ["get", ["$", "/user"], "/last_active_days"], 10]]
        ]
      ]
    ]],
    ["pipeline_stats", ["obj",
      ["total_users", ["count", ["$", "/users"]]],
      ["active_users", ["count", 
        ["filter", ["$", "/users"],
          ["lambda", ["user"], [">", ["get", ["$", "/user"], "/last_active_days"], ["$", "/active_threshold"]]]
        ]
      ]]
    ]]
  ]
]

input = '''
{
  "active_days_threshold": 7,
  "users": [
    {"name": "Alice", "department": "Engineering", "last_active_days": 1},
    {"name": "Bob", "department": "Marketing", "last_active_days": 15},
    {"name": "Carol", "department": "Engineering", "last_active_days": 30},
    {"name": "David", "department": "Sales", "last_active_days": 5}
  ]
}
'''

expected = '''
{
  "optimized_pipeline": [
    {"name": "Bob", "department": "Marketing", "activity_score": 150},
    {"name": "Carol", "department": "Engineering", "activity_score": 300}
  ],
  "pipeline_stats": {
    "total_users": 4,
    "active_users": 2
  }
}
'''

notes = "The optimized pipeline filters users first (reducing dataset from 4 to 2), then maps only the remaining items, avoiding unnecessary object creation."
cli_flags = ["--pretty=2"] 